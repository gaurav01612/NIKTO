#!/usr/bin/env python3
"""
Ultimate Safe Web Scanner (Tkinter GUI) - full-featured, passive & educational

Author: Generated by assistant (user requested a full advanced scanner)
License: Educational / personal use only

This script provides:
 - Tkinter GUI with soothing dark theme
 - Resizable panels using PanedWindow
 - Multi-threaded passive checks (headers, robots, sitemap, common paths)
 - TLS certificate retrieval and basic analysis
 - TCP connect banner grabs for common ports (non-invasive)
 - DNS & WHOIS lookups (optional libraries)
 - HTML parsing (links, forms, scripts) - requires beautifulsoup4
 - Technology fingerprinting using headers/HTML/favicon
 - Pluggable checks via checks.csv
 - Export to CSV, JSON, HTML
 - Persistence of some settings
 - Strictly non-exploitative (no injection, no fuzzing, no brute force)
"""

# standard libraries
import os
import sys
import time
import json
import csv
import ssl
import socket
import hashlib
import re
import threading
import queue
from datetime import datetime
from urllib.parse import urlparse, urljoin

# GUI
try:
    import tkinter as tk
    from tkinter import ttk, messagebox, filedialog
except Exception:
    print("Tkinter not available. On Debian/Ubuntu: sudo apt-get install python3-tk")
    raise

# HTTP and parsing
import requests
try:
    from bs4 import BeautifulSoup
except Exception:
    BeautifulSoup = None

# Optional libraries
try:
    import tldextract
except Exception:
    tldextract = None

try:
    import dns.resolver
except Exception:
    dns = None

try:
    import whois
except Exception:
    whois = None

# --------------- Configuration & Defaults ---------------

APP_TITLE = "Web Scanner Toolkit"
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
SETTINGS_FILE = os.path.join(SCRIPT_DIR, "uss_settings.json")
CHECKS_CSV_DEFAULT = os.path.join(SCRIPT_DIR, "checks.csv")
PLACEHOLDER_URL = "https://example.com"

REQUEST_TIMEOUT = 10
DEFAULT_RATE_DELAY = 0.12
DEFAULT_THREADS = 6
MAX_THREADS = 40

COMMON_PORTS = [21, 22, 25, 80, 443, 8080, 8443, 3306, 1433, 9200, 27017]

SECURITY_HEADER_LIST = [
    "Content-Security-Policy",
    "X-Frame-Options",
    "X-Content-Type-Options",
    "Referrer-Policy",
    "Strict-Transport-Security",
    "Permissions-Policy",
]

DEFAULT_CHECKS = [
    ("/", "Root page", "Info", "GET"),
    ("/robots.txt", "robots.txt presence", "Info", "GET"),
    ("/sitemap.xml", "sitemap.xml presence", "Info", "GET"),
    ("/admin/", "Common admin directory (existence check)", "Low", "GET"),
    ("/.git/", "Exposed .git directory (existence check)", "High", "GET"),
    ("/phpinfo.php", "phpinfo.php exposure", "High", "GET"),
    ("/.env", ".env exposure", "High", "GET"),
    ("/wp-login.php", "WordPress login page", "Low", "GET"),
]

# Ensure requests will warn less about missing certificate verification if user disables verify
requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

# --------------- Utility helpers ---------------

def now_iso():
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

def safe_normalize_url(url: str) -> str:
    if not url:
        return ""
    url = url.strip()
    parsed = urlparse(url, "http")
    if not parsed.netloc and parsed.path:
        # user typed 'example.com'
        return "http://" + parsed.path
    if parsed.scheme == "":
        return "http://" + url
    return parsed.geturl()

def fetch_url(url: str, headers_only=False, verify=True, timeout=REQUEST_TIMEOUT):
    """
    Safe fetching that returns a dict: {url, status, headers, elapsed_ms, text_snippet, error}
    If headers_only True, try HEAD then fallback to GET.
    """
    res = {"url": url, "status": None, "headers": {}, "elapsed_ms": None, "text_snippet": "", "error": None}
    start = time.time()
    try:
        if headers_only:
            try:
                r = requests.head(url, timeout=timeout, allow_redirects=True, verify=verify)
                # Some servers return 405 for HEAD
                if r.status_code == 405 or (r.status_code >= 400 and not r.headers):
                    raise RuntimeError("HEAD unsupported or returned no headers")
            except Exception:
                r = requests.get(url, timeout=timeout, allow_redirects=True, verify=verify)
        else:
            r = requests.get(url, timeout=timeout, allow_redirects=True, verify=verify)
        res["elapsed_ms"] = int((time.time() - start) * 1000)
        res["status"] = r.status_code
        res["headers"] = dict(r.headers)
        try:
            res["text_snippet"] = (r.text or "")[:8000]
        except Exception:
            res["text_snippet"] = ""
    except Exception as e:
        res["error"] = str(e)
    return res

def tcp_connect(host: str, port: int, timeout=3):
    """
    Non-invasive TCP connect. Returns (ok: bool, banner_or_error: str)
    """
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        s.connect((host, port))
        banner = ""
        try:
            banner = s.recv(1024)
            s.close()
            return True, banner.decode(errors="ignore").strip()
        except Exception:
            try:
                s.close()
            except Exception:
                pass
            return True, ""
    except Exception as e:
        return False, str(e)

def get_tls_cert(host: str, port: int = 443, timeout=5):
    """
    Retrieves TLS peer cert and returns (ok, cert_dict_or_error)
    """
    try:
        context = ssl.create_default_context()
        with socket.create_connection((host, port), timeout=timeout) as sock:
            with context.wrap_socket(sock, server_hostname=host) as ssock:
                der = ssock.getpeercert(binary_form=True)
                parsed = ssock.getpeercert()
                return True, parsed
    except Exception as e:
        return False, str(e)

def compute_favicon_md5(base_url: str):
    try:
        fav = urljoin(base_url, "/favicon.ico")
        r = requests.get(fav, timeout=REQUEST_TIMEOUT)
        if r.status_code >= 400:
            return None
        return hashlib.md5(r.content).hexdigest()
    except Exception:
        return None

def parse_links_and_forms(html: str, base_url: str):
    links = []
    forms = []
    scripts = []
    if not BeautifulSoup:
        return links, forms, scripts
    try:
        soup = BeautifulSoup(html, "html.parser")
        # Links (a, link)
        for a in soup.find_all(["a", "link"]):
            url = a.get("href")
            if url:
                full = urljoin(base_url, url)
                links.append(full)
        # Scripts & images & iframes (src)
        for s in soup.find_all(["script", "img", "iframe"]):
            src = s.get("src")
            if src:
                scripts.append(urljoin(base_url, src))
        # Forms
        for f in soup.find_all("form"):
            action = f.get("action") or ""
            method = (f.get("method") or "GET").upper()
            inputs = []
            for inp in f.find_all(["input", "textarea", "select"]):
                inputs.append({"name": inp.get("name"), "type": inp.get("type")})
            forms.append({"action": urljoin(base_url, action), "method": method, "inputs": inputs})
    except Exception:
        pass
    return sorted(set(links)), forms, sorted(set(scripts))

# Simple fingerprint heuristics (extendable)
FINGERPRINT_RULES = [
    ("WordPress", re.compile(r"wp-(?:content|includes)|wp-json", re.I)),
    ("Joomla", re.compile(r"Joomla", re.I)),
    ("Drupal", re.compile(r"Drupal.settings", re.I)),
    ("php", re.compile(r"\.php", re.I)),
    ("ASP.NET", re.compile(r"ASP.NET", re.I)),
    ("nginx", re.compile(r"nginx", re.I)),
    ("Apache", re.compile(r"Apache", re.I)),
    ("IIS", re.compile(r"Microsoft-IIS", re.I)),
]

def fingerprint(headers: dict, html: str, favicon_hash: str = None):
    findings = []
    server = headers.get("Server", "")
    xp = headers.get("X-Powered-By", "")
    if server:
        findings.append(("Server", server))
    if xp:
        findings.append(("X-Powered-By", xp))
    text = (html or "") + " " + server + " " + xp
    for name, rx in FINGERPRINT_RULES:
        if rx.search(text):
            findings.append(("Tech", name))
    if favicon_hash:
        findings.append(("Favicon-MD5", favicon_hash))
    return findings

def load_checks_csv(path):
    checks = []
    try:
        if not os.path.exists(path):
            return checks
        with open(path, newline="", encoding="utf-8") as fh:
            reader = csv.reader(fh)
            for row in reader:
                if not row or row[0].strip().startswith("#"):
                    continue
                path0 = row[0].strip()
                desc = row[1].strip() if len(row) > 1 else path0
                sev = row[2].strip() if len(row) > 2 else "Low"
                method = row[3].strip().upper() if len(row) > 3 else "GET"
                checks.append((path0, desc, sev, method))
    except Exception:
        pass
    return checks

# ---------------- Settings persistence ----------------

DEFAULT_SETTINGS = {
    "theme": "dark",
    "threads": DEFAULT_THREADS,
    "rate_delay": DEFAULT_RATE_DELAY,
    "verify_ssl": True,
    "last_target": "",
    "last_checks": CHECKS_CSV_DEFAULT,
}

def load_settings():
    try:
        if os.path.exists(SETTINGS_FILE):
            with open(SETTINGS_FILE, "r", encoding="utf-8") as fh:
                data = json.load(fh)
                DEFAULT_SETTINGS.update(data)
    except Exception:
        pass
    return DEFAULT_SETTINGS.copy()

def save_settings(settings):
    try:
        with open(SETTINGS_FILE, "w", encoding="utf-8") as fh:
            json.dump(settings, fh, indent=2)
    except Exception:
        pass

# ---------------- UI / Application ----------------

class UltimateScannerApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(APP_TITLE)
        self.protocol("WM_DELETE_WINDOW", self.on_close)
        self.settings = load_settings()
        self._stop_event = threading.Event()
        self.results = []
        self.task_queue = queue.Queue()
        self.worker_threads = []
        self.checks = load_checks_csv(self.settings.get("last_checks", CHECKS_CSV_DEFAULT)) or DEFAULT_CHECKS

        # Initialize UI color defaults _before_ building UI so widgets can reference them
        # Soothing palette (dark)
        self.ui = {
            "bg": "#EEF6F6",          # main background
            "panel": "#E3F0F0",       # panels
            "card": "#FFFFFF",        # text areas / tables
            "fg": "#1F2D2D",          # text color
             "muted": "#6B8A8A",
             "accent": "#2F7E8C",      # buttons / headers
             "accent_dark": "#256B77", # hover / active
             "border": "#B7D6D6"
        }
        # theme variable
        # UI variables
        self.url_var = tk.StringVar(value=self.settings.get("last_target", PLACEHOLDER_URL))
        self.threads_var = tk.IntVar(value=self.settings.get("threads", DEFAULT_THREADS))
        self.rate_var = tk.DoubleVar(value=self.settings.get("rate_delay", DEFAULT_RATE_DELAY))
        self.verify_ssl_var = tk.BooleanVar(value=self.settings.get("verify_ssl", True))
        self.headers_only_var = tk.BooleanVar(value=False)

        # Build UI
        self._setup_style()
        self._build_ui()
        # Apply theme visuals
        self.apply_theme()
        # After UI build tasks
        self._log("Ready.")

    def _setup_style(self):
        style = ttk.Style(self)
        style.theme_use("clam")

        style.configure(
        "TFrame",
        background=self.ui["bg"]
    )

        style.configure(
        "TLabel",
        background=self.ui["bg"],
        foreground=self.ui["fg"],
        font=("Segoe UI", 10)
    )

        style.configure(
        "Header.TLabel",
        foreground=self.ui["accent"],
        font=("Segoe UI", 11, "bold")
    )

        style.configure(
        "TButton",
        background=self.ui["accent"],
        foreground="white",
        padding=(10, 6),
        font=("Segoe UI", 10, "bold")
    )

        style.map(
        "TButton",
        background=[("active", self.ui["accent_dark"])]
    )

        style.configure(
        "Treeview",
        background=self.ui["card"],
        fieldbackground=self.ui["card"],
        foreground=self.ui["fg"],
        rowheight=24,
        font=("Segoe UI", 9)
    )

        style.configure(
        "Treeview.Heading",
        background=self.ui["accent"],
        foreground="white",
        font=("Segoe UI", 10, "bold")
    )

        style.map(
        "Treeview",
        background=[("selected", "#D6ECEC")],
        foreground=[("selected", "#000000")]
    )

    def apply_theme(self):
        colors = self.ui  # fixed theme only

        self.configure(bg=colors["bg"])

        for txt in getattr(self, "_textboxes", []):
             txt.configure(
                bg=colors["card"],
                fg=colors["fg"],
                insertbackground=colors["fg"]
        )
        self.colors = colors

        # set window bg
        self.configure(bg=colors["bg"])
        # apply to known text boxes
        for txt in getattr(self, "_textboxes", []):
            txt.configure(bg=colors["card"], fg=colors["fg"], insertbackground=colors["fg"])
        # store current color set for later
        self.colors = colors

    def _build_ui(self):
        # top bar
        top = ttk.Frame(self, padding=8)
        top.pack(side="top", fill="x", padx=8, pady=(8, 4))

        ttk.Label(top, text="Target URL:", style="Header.TLabel").pack(side="left")
        self.entry_url = ttk.Entry(top, textvariable=self.url_var, width=60)
        self.entry_url.pack(side="left", padx=(8, 8))
        self.entry_url.bind("<FocusIn>", self._on_url_focus_in)
        self.entry_url.bind("<FocusOut>", self._on_url_focus_out)

        self.btn_start = ttk.Button(top, text="▶ Start Scan", command=self.start_scan)
        self.btn_start.pack(side="left", padx=(0, 6))
        self.btn_stop = ttk.Button(top, text="■ Stop", command=self.stop_scan, state="disabled")
        self.btn_stop.pack(side="left", padx=(0, 6))
        self.btn_export = ttk.Button(top, text="Export", command=self._export_menu)
        self.btn_export.pack(side="left", padx=(0, 6))

        # options row
        opts = ttk.Frame(self, padding=6)
        opts.pack(side="top", fill="x", padx=8)

        ttk.Checkbutton(opts, text="Verify SSL", variable=self.verify_ssl_var).pack(side="left", padx=(0, 6))
        ttk.Checkbutton(opts, text="Headers-only (fast)", variable=self.headers_only_var).pack(side="left", padx=(0, 6))
        ttk.Label(opts, text="Threads:").pack(side="left", padx=(12, 2))
        self.spin_threads = ttk.Spinbox(opts, from_=1, to=MAX_THREADS, textvariable=self.threads_var, width=5)
        self.spin_threads.pack(side="left")
        ttk.Label(opts, text="Rate delay (s):").pack(side="left", padx=(8, 2))
        self.entry_rate = ttk.Entry(opts, textvariable=self.rate_var, width=6)
        self.entry_rate.pack(side="left")

        ttk.Button(opts, text="Load checks.csv", command=self.load_checks_file).pack(side="right", padx=(6,0))
        ttk.Label(opts, text="Checks file:").pack(side="right")

        # main paned window (horizontal split)
        main_pane = ttk.Panedwindow(self, orient=tk.HORIZONTAL)
        main_pane.pack(fill="both", expand=True, padx=8, pady=(6,8))

        # left vertical pane for headers & log
        left_pane = ttk.Panedwindow(main_pane, orient=tk.VERTICAL)
        main_pane.add(left_pane, weight=1)

        # headers frame (top-left)
        headers_frame = ttk.Labelframe(left_pane, text="Response headers & summary", padding=8)
        left_pane.add(headers_frame, weight=1)
        self.txt_headers = tk.Text(headers_frame, height=12, wrap="none")
        self.txt_headers.pack(fill="both", expand=True)
        # horizontal scrollbar for headers
        hbar_headers = ttk.Scrollbar(headers_frame, orient="horizontal", command=self.txt_headers.xview)
        self.txt_headers.configure(xscrollcommand=hbar_headers.set)
        hbar_headers.pack(fill="x")

        # log frame (bottom-left)
        log_frame = ttk.Labelframe(left_pane, text="Console log", padding=8)
        left_pane.add(log_frame, weight=1)
        self.txt_log = tk.Text(log_frame, height=12, wrap="word")
        self.txt_log.pack(fill="both", expand=True)

        # register text boxes for theme updates
        self._textboxes = [self.txt_headers, self.txt_log]

        # right frame for findings
        right_frame = ttk.Frame(main_pane)
        main_pane.add(right_frame, weight=2)

        results_frame = ttk.Labelframe(right_frame, text="Findings (select row)", padding=8)
        results_frame.pack(fill="both", expand=True, padx=(8,0), pady=(0,0))

        cols = ("time", "severity", "type", "detail")
        self.tree = ttk.Treeview(results_frame, columns=cols, show="headings", selectmode="browse")
        sizes = [140, 80, 180, 520]
        for c, w in zip(cols, sizes):
            self.tree.heading(c, text=c.capitalize())
            self.tree.column(c, width=w, anchor="w", stretch=True)
        self.tree.pack(fill="both", expand=True, side="left")
        ysb = ttk.Scrollbar(results_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=ysb.set)
        ysb.pack(side="left", fill="y")
        self.tree.bind("<<TreeviewSelect>>", self.on_tree_select)

        # detail panel below on right
        detail_frame = ttk.Labelframe(right_frame, text="Selected detail", padding=8)
        detail_frame.pack(fill="x", padx=(8,0), pady=(8,8))
        self.txt_detail = tk.Text(detail_frame, height=8, wrap="word")
        self.txt_detail.pack(fill="both", expand=True)
        self._textboxes.append(self.txt_detail)

        # bottom bar
        bottom = ttk.Frame(self, padding=6)
        bottom.pack(side="bottom", fill="x", padx=8, pady=(0,8))
        self.progress = ttk.Progressbar(bottom, length=420, mode="determinate")
        self.progress.pack(side="left", padx=(0,8))
        ttk.Button(bottom, text="Show details", command=self.show_selected_details).pack(side="left", padx=6)
        ttk.Button(bottom, text="Clear results", command=self.clear_results).pack(side="left", padx=6)

    # ---------------- UI helpers ----------------
    def _on_url_focus_in(self, event):
        if self.url_var.get() == PLACEHOLDER_URL:
            self.url_var.set("")

    def _on_url_focus_out(self, event):
        if not self.url_var.get().strip():
            self.url_var.set(PLACEHOLDER_URL)

    def _log(self, text):
        line = f"[{now_iso()}] {text}"
        self.txt_log.insert("end", line + "\n")
        self.txt_log.see("end")

    def _add_result(self, severity, rtype, detail, meta=None, raw=None):
        t = now_iso()
        self.results.append({"time": t, "severity": severity, "type": rtype, "detail": detail, "meta": meta or {}, "raw": raw})
        iid = self.tree.insert("", "end", values=(t, severity, rtype, detail))
        tag = severity.lower()
        if tag == "high":
            self.tree.tag_configure("high", background="#CB6767")
            self.tree.item(iid, tags=("high",))
        elif tag == "medium":
            self.tree.tag_configure("medium", background="#7fcaca")
            self.tree.item(iid, tags=("medium",))
        elif tag == "low":
            self.tree.tag_configure("low", background="#42AD4B")
            self.tree.item(iid, tags=("low",))
        else:
            self.tree.tag_configure("info", background=self.colors.get("card", "#0f2b36"))
            self.tree.item(iid, tags=("info",))
        self.tree.see(iid)

    def on_tree_select(self, event):
        sel = self.tree.selection()
        if not sel:
            return
        iid = sel[0]
        idx = self.tree.index(iid)
        if 0 <= idx < len(self.results):
            r = self.results[idx]
            txt = f"Type: {r['type']}\nSeverity: {r['severity']}\nTime: {r['time']}\n\nDetail:\n{r['detail']}\n\nMeta:\n{json.dumps(r['meta'], indent=2, ensure_ascii=False)}\n\nRaw:\n{json.dumps(r['raw'], indent=2, ensure_ascii=False)}"
            self.txt_detail.delete("1.0", "end")
            self.txt_detail.insert("end", txt)
            self.txt_detail.see("1.0")

    def show_selected_details(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showinfo("Details", "No row selected.")
            return
        self.on_tree_select(None)
        messagebox.showinfo("Details", "Details shown in the bottom panel.")

    def clear_results(self):
        self.results = []
        for iid in self.tree.get_children():
            self.tree.delete(iid)
        self.txt_headers.delete("1.0", "end")
        self.txt_log.delete("1.0", "end")
        self.txt_detail.delete("1.0", "end")
        self.progress['value'] = 0
        self._log("Cleared results.")

    # ---------------- Exporting ----------------
    def _export_menu(self):
        menu = tk.Menu(self, tearoff=0)
        menu.add_command(label="Export CSV", command=self.export_csv)
        menu.add_command(label="Export JSON", command=self.export_json)
        menu.add_command(label="Export HTML", command=self.export_html)
        try:
            menu.tk_popup(self.winfo_rootx() + 200, self.winfo_rooty() + 30)
        finally:
            menu.grab_release()

    def export_csv(self):
        if not self.results:
            messagebox.showinfo("Export", "No results to export.")
            return
        f = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files","*.csv")])
        if not f:
            return
        with open(f, "w", newline="", encoding="utf-8") as fh:
            w = csv.writer(fh)
            w.writerow(["time","severity","type","detail","meta","raw"])
            for r in self.results:
                w.writerow([r["time"], r["severity"], r["type"], r["detail"], json.dumps(r["meta"], ensure_ascii=False), json.dumps(r["raw"], ensure_ascii=False)])
        messagebox.showinfo("Export", f"Exported CSV to:\n{f}")

    def export_json(self):
        if not self.results:
            messagebox.showinfo("Export", "No results to export.")
            return
        f = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON files","*.json")])
        if not f:
            return
        out = {"generated": now_iso(), "target": self.url_var.get(), "results": self.results}
        with open(f, "w", encoding="utf-8") as fh:
            json.dump(out, fh, indent=2, ensure_ascii=False)
        messagebox.showinfo("Export", f"Exported JSON to:\n{f}")

    def export_html(self):
        if not self.results:
            messagebox.showinfo("Export", "No results to export.")
            return
        f = filedialog.asksaveasfilename(defaultextension=".html", filetypes=[("HTML files","*.html")])
        if not f:
            return
        title = f"Scan Report - {now_iso()}"
        header_html = f"<h2 style='color:#e6eef8'>{html_escape(self.url_var.get())}</h2><p>Generated: {html_escape(now_iso())}</p>"
        rows = ""
        for r in self.results:
            rows += "<tr>"
            rows += f"<td>{html_escape(r['time'])}</td>"
            rows += f"<td>{html_escape(r['severity'])}</td>"
            rows += f"<td>{html_escape(r['type'])}</td>"
            rows += f"<td>{html_escape(r['detail'])}</td>"
            rows += "</tr>\n"
        html_doc = f"""<!doctype html>
<html><head><meta charset="utf-8"><title>{html_escape(title)}</title>
<style>
body{{font-family:Segoe UI,Arial;padding:18px;background:#0f1720;color:#e6eef8}}
table{{border-collapse:collapse;width:100%}}
th,td{{border:1px solid #123;padding:8px;text-align:left}}
th{{background:#2a8a99;color:#fff}}
tr:nth-child(even){{background:#071826}}
</style></head><body>
<h1 style="color:#fff">Advanced Scan Report</h1>
{header_html}
<table><thead><tr><th>Time</th><th>Severity</th><th>Type</th><th>Detail</th></tr></thead><tbody>
{rows}
</tbody></table>
</body></html>"""
        with open(f, "w", encoding="utf-8") as fh:
            fh.write(html_doc)
        messagebox.showinfo("Export", f"HTML saved to:\n{f}")

    # ---------------- Load checks file ----------------
    def load_checks_file(self):
        path = filedialog.askopenfilename(title="Open checks CSV", filetypes=[("CSV files","*.csv")], initialdir=SCRIPT_DIR)
        if not path:
            return
        self.checks = load_checks_from_csv(path) or DEFAULT_CHECKS # type: ignore
        self.settings["last_checks"] = path
        save_settings(self.settings)
        messagebox.showinfo("Checks loaded", f"Loaded {len(self.checks)} checks from:\n{path}")
        self._log(f"Loaded checks from {path} ({len(self.checks)} entries)")

    # ---------------- Scan orchestration ----------------
    def start_scan(self):
        raw = self.url_var.get().strip()
        if not raw or raw == PLACEHOLDER_URL:
            messagebox.showwarning("Invalid target", "Please enter a valid target URL.")
            return
        target = safe_normalize_url(raw)
        if not target:
            messagebox.showwarning("Invalid target", "Please enter a valid URL.")
            return
        if not messagebox.askyesno("Permission", "Only scan sites you own or have permission to test. Continue?"):
            return
        # Save last target
        self.settings["last_target"] = raw
        self.settings["threads"] = int(self.threads_var.get())
        self.settings["rate_delay"] = float(self.rate_var.get())
        self.settings["verify_ssl"] = bool(self.verify_ssl_var.get())
        save_settings(self.settings)

        # Reset UI
        self.clear_results()
        self._stop_event.clear()
        self.btn_start.config(state="disabled")
        self.btn_stop.config(state="normal")
        tcount = max(1, min(MAX_THREADS, int(self.threads_var.get())))
        rate = float(self.rate_var.get()) if self.rate_var.get() else DEFAULT_RATE_DELAY
        self._log(f"Starting scan on {target} (threads={tcount}, rate={rate}s, verify_ssl={self.verify_ssl_var.get()})")
        manager = threading.Thread(target=self._manager_thread, args=(target, tcount, rate), daemon=True)
        manager.start()

    def stop_scan(self):
        self._stop_event.set()
        self._log("Stop requested.")
        self.btn_stop.config(state="disabled")
        self.btn_start.config(state="normal")

    def _manager_thread(self, target, threads, rate):
        """
        Build tasks and run a pool of worker threads.
        Tasks: fetch_root, favicon, tls, dns/whois, ports, robots, sitemap, checks...
        """
        parsed = urlparse(target)
        base = f"{parsed.scheme}://{parsed.netloc}"
        host = parsed.hostname

        tasks = []
        # root fetch
        tasks.append(("fetch_root", {"url": base}))
        # favicon
        tasks.append(("favicon", {"base": base}))
        # tls info
        tasks.append(("tls", {"host": host}))
        # dns/whois
        tasks.append(("dns_whois", {"host": host}))
        # ports
        tasks.append(("ports", {"host": host}))
        # robots & sitemap
        tasks.append(("path", {"url": urljoin(base, "/robots.txt"), "desc": "robots.txt", "sev": "Info", "method": "GET"}))
        tasks.append(("path", {"url": urljoin(base, "/sitemap.xml"), "desc": "sitemap.xml", "sev": "Info", "method": "GET"}))
        # customizable checks
        checks = self.checks or DEFAULT_CHECKS
        for path, desc, sev, method in checks:
            tasks.append(("path", {"url": urljoin(base, path), "desc": desc, "sev": sev, "method": method}))

        # push tasks to queue
        q = queue.Queue()
        total = len(tasks)
        for t in tasks:
            q.put(t)
        self.progress['maximum'] = total
        self.progress['value'] = 0

        # start worker threads
        workers = []
        for _ in range(max(1, threads)):
            w = threading.Thread(target=self._worker_loop, args=(q, rate), daemon=True)
            w.start()
            workers.append(w)

        # wait for tasks to be done or stop event
        while not q.empty() and not self._stop_event.is_set():
            time.sleep(0.2)
        # ensure all done
        q.join()
        self._log("All tasks complete.")
        # re-enable start button
        self.btn_start.config(state="normal")
        self.btn_stop.config(state="disabled")
        self.progress['value'] = self.progress['maximum']

    def _worker_loop(self, q: queue.Queue, rate: float):
        while not q.empty() and not self._stop_event.is_set():
            try:
                task, payload = q.get_nowait()
            except Exception:
                break
            try:
                if task == "fetch_root":
                    self._do_fetch_root(payload["url"])
                elif task == "favicon":
                    self._do_favicon(payload["base"])
                elif task == "tls":
                    self._do_tls(payload["host"])
                elif task == "dns_whois":
                    self._do_dns_whois(payload["host"])
                elif task == "ports":
                    self._do_ports(payload["host"])
                elif task == "path":
                    self._do_path_check(payload["url"], payload.get("desc", payload["url"]), payload.get("sev", "Low"), payload.get("method", "GET"))
                # step progress
                self.progress.after(0, lambda: self.progress.step(1))
            except Exception as e:
                self._log(f"Worker exception: {e}")
            finally:
                q.task_done()
            time.sleep(rate)

    # ---------------- Task implementations ----------------
    def _do_fetch_root(self, url: str):
        self._log(f"Fetching root: {url}")
        info = fetch_url(url, headers_only=self.headers_only_var.get(), verify=self.verify_ssl_var.get())
        if info.get("error"):
            self._add_result("High", "Fetch error", info.get("error"), raw=info)
            return
        # update header box
        header_lines = [f"URL: {info['url']}", f"Status: {info['status']}", f"Response time: {info['elapsed_ms']} ms", ""]
        for k, v in info["headers"].items():
            header_lines.append(f"{k}: {v}")
        self.txt_headers.after(0, lambda: self.txt_headers.insert("end", "\n".join(header_lines) + "\n\n"))
        # check security headers
        missing = [h for h in SECURITY_HEADER_LIST if h not in info["headers"]]
        if missing:
            for h in missing:
                self._add_result("Medium", "Missing header", f"{h}")
        else:
            self._add_result("Info", "Security headers", "All common security headers present")
        # fingerprint & parse
        fav = compute_favicon_md5(url)
        techs = fingerprint(info.get("headers", {}), info.get("text_snippet", ""), fav)
        for t in techs:
            self._add_result("Info", "Fingerprint", f"{t[0]}: {t[1]}", meta={"source":"headers/html"})
        # links & forms
        links, forms, scripts = parse_links_and_forms(info.get("text_snippet", ""), info.get("url"))
        if links:
            self._add_result("Info", "Links found", f"{len(links)} links discovered", meta={"sample": links[:6]})
        if forms:
            self._add_result("Info", "Forms found", f"{len(forms)} forms discovered", meta={"sample": forms[:6]})

    def _do_path_check(self, url, desc, sev, method="GET"):
        self._log(f"Checking path: {url} ({method})")
        try:
            if method.upper() == "HEAD":
                r = requests.head(url, timeout=REQUEST_TIMEOUT, allow_redirects=True, verify=self.verify_ssl_var.get())
            else:
                r = requests.get(url, timeout=REQUEST_TIMEOUT, allow_redirects=True, verify=self.verify_ssl_var.get())
            if isinstance(r, Exception):
                self._add_result("Low", desc, f"Request error: {r}")
                return
            status = r.status_code
            if status < 400:
                snippet = ""
                try:
                    snippet = (r.text or "")[:800].replace("\n", " ")
                except Exception:
                    snippet = ""
                self._add_result(sev, desc, f"Found (HTTP {status}) - {url}", meta={"snippet": snippet})
            else:
                self._add_result("Info", desc, f"Returned HTTP {status}", meta={"url": url})
        except Exception as e:
            self._add_result("Low", desc, f"Error: {e}")

    def _do_favicon(self, base):
        self._log("Checking favicon")
        try:
            h = compute_favicon_md5(base)
            if h:
                self._add_result("Info", "Favicon hash", h, meta={"url": base + "/favicon.ico"})
            else:
                self._add_result("Info", "Favicon", "Not found or unreachable")
        except Exception as e:
            self._log(f"Favicon error: {e}")

    def _do_tls(self, host):
        if not host:
            return
        self._log(f"Getting certificate for {host}")
        ok, info = get_tls_cert(host)
        if ok:
            self._add_result("Info", "TLS cert", "Certificate retrieved", meta=info)
            not_after = info.get("notAfter")
            if not_after:
                self._add_result("Info", "TLS expiry", f"NotAfter: {not_after}")
        else:
            self._add_result("Low", "TLS info", f"Could not retrieve TLS data: {info}")

    def _do_dns_whois(self, host):
        if not host:
            return
        self._log(f"DNS & WHOIS for {host}")
        # DNS A
        if dns:
            try:
                ans = dns.resolver.resolve(host, "A")
                a_records = [r.to_text() for r in ans]
                self._add_result("Info", "DNS A", ", ".join(a_records))
            except Exception as e:
                self._log(f"DNS A lookup failed: {e}")
        else:
            self._log("dnspython not installed; skipping DNS lookups")
        # WHOIS
        if whois:
            try:
                w = whois.whois(host)
                self._add_result("Info", "WHOIS", "WHOIS fetched", meta={"whois": str(w)[:800]})
            except Exception as e:
                self._log(f"WHOIS lookup error: {e}")
        else:
            self._log("python-whois not installed; skipping whois")

    def _do_ports(self, host):
        if not host:
            return
        self._log(f"Checking common ports on {host}")
        for p in COMMON_PORTS:
            if self._stop_event.is_set():
                return
            ok, banner = tcp_connect(host, p, timeout=2)
            if ok:
                self._add_result("Info", "Open port", f"{host}:{p} open", meta={"banner": banner})
            time.sleep(0.06)

    # ---------------- Shutdown ----------------
    def on_close(self):
        if messagebox.askokcancel("Quit", "Stop scan and exit?"):
            self._stop_event.set()
            self.destroy()

# Helper: html escape
def html_escape(s):
    if not s:
        return ""
    return (s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;"))

# ---------------- Main ---------------
def main():
    # Print optional-libs notice
    notices = []
    if not BeautifulSoup:
        notices.append("beautifulsoup4 missing (HTML parsing reduced)")
    if not tldextract:
        notices.append("tldextract missing (domain heuristics reduced)")
    if not dns:
        notices.append("dnspython missing (DNS checks disabled)")
    if not whois:
        notices.append("python-whois missing (WHOIS disabled)")
    if notices:
        print("Note:", " ; ".join(notices))
    app = UltimateScannerApp()
    app.mainloop()

if __name__ == "__main__":
    main()